РАЗРАБОТКА И ПРИМЕНЕНИЕ СТАТИЧЕСКИХ И ДИНАМИЧЕСКИХ БИБЛИОТЕК С-ФУНКЦИЙ В LINUX

ЦЕЛЬ РАБОТЫ: 
Ознакомиться особенностями создания и применения статических и динамических библиотек С-функций в среде ОС Linux.

КРАТКИЕ ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ. 
Библиотека объектных файлов - это файл содержащий несколько объектных файлов, которые будут использоваться вместе в стадии линковки программы. Объектные библиотеки по способу использования разделяются на два вида: статические библиотеки и динамические библиотеки. 

Статическая библиотека - это коллекция объектных файлов, которые присоединяются к программе во время линковки программы. 
Таким образом статические библиотеки используются только при создании программы.
Потом в работе самой программы они не принимают участие, в отличие от динамических библиотек. 

Динамическая библиотека - это созданная специальным образом библиотека, которая присоединяется к результирующей программе в два этапа. 
Первый этап, это естественно этап компиляции.
На этом этапе линковщик встраивает в программу описания требуемых функций и переменных, которые присутствуют в библиотеке.
Сами объектные файлы из библиотеки не присоединяются к программе. 
Присоединение этих объектных файлов(кодов функций) осуществляет системный динамический загрузчик во время запуска программы. 
Загрузчик проверяет все библиотеки прилинкованные с программе на наличие требуемых объектных файлов, затем загружает их в память и присоединяет их в копии запущенной программы, находящейся в памяти. 

Для того, чтобы создать библиотеку из объектых файлов надо вызвать программу ar со следующими параметрами: 
	ar rc libимя_библиотеки.a [список_*.o_файлов]
В результате получим файл libимя_библиотеки.a, в котором будут лежать копии объектых файлов f1.o и f2.o.
Если файл библиотеки уже существует, то архиватор будет анализировать содержимое архива, он добавит новые объектные файлы и заменит старые обновленными версиями.
Опция c заставляет создавать (от create) библиотеку, если ее нет, а опция r (от replace) заменяет старые объектные файлы новыми версиями.
Чтобы из него сделать полноценную библиотеку объектных файлов надо добавить к этому архиву индекс символов, т.е. список вложенных в библиотеку функций и переменных, чтобы линковка происходила быстрее. Далается это командой: 
	ranlib libимя_библиотеки.a
Программа ranlib добавит индекс к архиву и получится полноценная статическая библиотека объектных файлов. 

Для компиляции основного файла надо сообщить компилятору, что требуется использовать библиотеки.
Чтобы компилятор знал, где искать библиотеки ему надо сообщить каталог, в котором они содержатся и список этих библиотек.
Каталог с библиотеками указывается ключом -L, в нашем случае библиотека находится в текущем каталоге, значит, путь до нее будет в виде точки (-L.). Используемые библиотеки перечисляются через ключ -l, после которого указывается название библиотеки без префикса lib и окончания .a. 

Все объектные файлы, создаваемые обычным образом, не имеют представления о том в какие адреса памяти будет загружена использующая их программа. Несколько различных программ могут использовать одну библиотеку, и каждая из них располагается в различном адресном пространстве.
Поэтому требуется, чтобы переходы в функциях библиотеки использовали не абсолютную адресацию, а относительную. То есть генерируемый компилятором код должен быть независимым от адресов, такая технология получила название PIC - Position Independent Code. В компиляторе gcc данная возможность включается ключом -fPIC. 
Динамическая библиотека это уже не архивный файл, а настоящая загружаемая программа, поэтому созданием динамических библиотек занимается сам компилятор gcc. Для того, чтобы создать динамическую библиотеку надо использовать ключ –shared.
Часто динамический линковщик просто не может найти файл динамической библиотеки, поскольку ищет файл в известных ему директориях, а текущая директория ему не известна. 
Выяснить неизвестные библиотеки поможет программа ldd. Она выдает на экран список динамических библиотек используемых в программе и их местоположение. В качестве параметра ей сообщается название обследуемой программы.
Добавить библиотеку в путь поиска можно с помощью специальной переменной среды LD_LIBRARY_PATH, в которой перечисляются все каталоги содержащие пользовательские динамические библиотеки.
Для того, чтобы установить эту переменную в командной среде bash надо набрать всего несколько команд. Для начала посмотрим есть ли у нас такая переменная среды: 
	$ echo $LD_LIBRARY_PATH
Устанавливается она следующим образом: 
	$ LD_LIBRARY_PATH=/root
	$ export LD_LIBRARY_PATH

Использовать динамические библиотеки можно не только в начале загрузки, но и в процессе самой работы программы.
Программа сама может вызывать любые функции из библиотеки, когда ей захочется. Для этого всего лишь надо использовать библиотеку dl, которая позволяет линковать библиотеки "на лету".
Она управляет загрузкой динамических библиотек, вызовом функций из них и выгрузкой после конца работы.
Для использования функций программной работы с динамическими библиотеками необходимо подключить заголовочный файл: 
	#include <dlfcn.h>
Чтобы вызывать какие-то функции из динамической библиотеки сначала надо открыть эту библиотеку (можно сказать "загрузить"). Открывается она функцией: 
	void *dlopen (const char *filename, int flag);
Параметр filename содержит путь до требуемой библиотеки, а параметр flag задает некоторые специфические флаги для работы.
Функция возвращает указатель на загруженную библиотеку.
В случае любой ошибки возвращается указатель NULL.
В таком случае тест ошибки понятный человеку можно получить с помощью функции dlerror().Пока мы не будем задумываться над этим, и я приведу стандартный код для открытия библиотеки: 
void *library_handler;
//......
//загрузка библиотеки
library_handler = dlopen("/path/to/the/library.so",RTLD_LAZY);
if (!library_handler){
	//если ошибка, то вывести ее на экран
	fprintf(stderr,"dlopen() error: %s\n", dlerror());
	exit(1); // в случае ошибки можно, например, закончить работу программы
};
После этого можно работать с библиотекой. 
А работа эта заключается в получении адреса требуемой функции из библиотеки. Получить адрес функции или переменной можно по ее имени с помощью функции: 
	void *dlsym(void *handle, char *symbol);
Для этой функции требуется адрес загруженной библиотеки handle, полученный при открытии функцией dlopen().Требуемая функция или переменная задается своим именем в переменной symbol. 
Закрывается библиотека функцией: 
	dlclose(void *handle);
При закрытии библиотеки динамический линковщик проверяет счетчик количества открытий библиотеки, и если она была открыта несколькими программами одновременно, то она не выгружается до тех пор, пока все программы не закроют эту библиотеку. 
Код главной программы требуется откомпилировать с использованием библиотеки dl: 
	$ gcc main.c -o main -ldl
Часто функции библиотеки для работы требуют правильно инициализированные переменные (буфер или массив). Специально для таких случаев в библиотеках можно задавать инициализирующую и деинициализирующую функции: 
	void _init() - инициализация 
	void _fini() - деинициализация 
Для такой библиотеки надо использовать ключ компилятора -nostdlib: 
	[gun]$ gcc -shared -nostdlib lib1.o -o libtest.so

?===============?
ЗАДАНИЕ:
1.Разработать функции для выполнения арифметических операций по вариантам. 
2.Оформить статическую библиотеку функций и написать программу, ее использующую.
3.Переоформить библиотеку, как динамическую, но подгружать статически, при компиляции.
4.Изменить программу для динамической загрузки функций из библиотеки.

Варианты заданий. 
1.Операции сложения и вычитания.
2.Операции умножения и деления.
3.Операции возведения в квадрат и извлечения корня.
4.Операции деления по модулю и нацело.
5.Операции возведения в куб и четвертую степень.
6.Операции склейки и разрыва строк.
?===============?

!===============!
СОСТАВИТЕЛИ:
Гунько А.В., канд. техн. наук, доц. НГТУ
Чистяков Н.А., инженер НГТУ
!===============!

!===============!
ССЫЛКИ:
http://www.firststeps.ru/linux/
http://www.thegeekstuff.com/2012/06/linux-shared-libraries/
http://cpp.com.ru/kr_cbook/index.html
http://cpp.com.ru/shildt_spr_po_c/index.html
http://cpp.com.ru/bogatyrev_c_unix/
http://gun.cs.nstu.ru/cpp
!===============!
