ЛАБОРАТОРНАЯ РАБОТА №6
МНОГОЗАДАЧНОЕ ПРОГРАММИРОВАНИЕ В LINUX

1. ЦЕЛЬ РАБОТЫ: Ознакомиться с компилятором gcc, методикой отладки программ, функциями работы с процессами.

2. КРАТКИЕ ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ. 
Минимальным набором ключей компилятора gcc являются -Wall (выводить все ошибки и предупреждения) и -o (output file): 
	gcc -Wall -o print_pid print_pid.c
Команда создаст исполняемый файл print_pid.
Стандартная библиотека C (libc, реализованная в Linux в glibc), использует возможности многозадачности Unix System V (далее SysV).
В libc тип pid_t определен как целое, способное вместить в себе pid. 
Функция, которая сообщает pid текущего процесса, имеет прототип pid_t getpid (void) и определена вместе с pid_t в unistd.h и sys/types.h).
Для создания нового процесса используется системный вызов fork:
	pid_t fork(void)
При вызове fork() порождается новый процесс (процесс-потомок), который почти идентичен порождающему процессу-родителю. Процесс-потомок наследует следующие признаки родителя: 
	- сегменты кода, данных и стека программы;
	- таблицу файлов, в которой находятся состояния флагов дескрипторов файла, указывающие, читается ли файл или пишется. Кроме того, в таблице файлов содержится текущая позиция указателя записи-чтения; 
	- рабочий и корневой каталоги;
	- реальный и эффективный номер пользователя и номер группы;
	- приоритеты процесса (администратор может изменить их через nice);
	- контрольный терминал;
	- маску сигналов;
	- ограничения по ресурсам;
	- сведения о среде выполнения;
	- разделяемые сегменты памяти.
Потомок не наследует от родителя следующих признаков:
	- идентификатора процесса (PID, PPID);
	- израсходованного времени ЦП (оно обнуляется);
	- сигналов процесса-родителя, требующих ответа;
	- блокированных файлов (record locking).
При вызове fork() возникают два полностью идентичных процесса.
Весь код после fork() выполняется дважды, как в процессе-потомке, так и в процессе-родителе.
Процесс-потомок и процесс-родитель получают разные коды возврата после вызова fork().
Процесс-родитель получает идентификатор (PID) потомка. Если это значение будет отрицательным, следовательно при порождении процесса произошла ошибка.
Процесс-потомок получает в качестве кода возврата значение 0, если вызов fork() оказался успешным.
Вставляя задержку случайной длины при помощи функций sleep и rand, можно нагляднее увидеть эффект многозадачности:
	sleep(rand()%4)
это заставит программу "заснуть" на случайное число секунд: от 0 до 3.

//--- fork.c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main(int argc, char* argv[]) {
		
        pid_t pid = fork();	/* fork returns type pid_t */
        srand(getpid());
        int t = rand()%4;
        printf("sleep time=%d pid=%d \n", t, pid);
        sleep(t);
        printf("fork() returned %d\n",  pid);
}

//---------------
+===============+
$ gcc -Wall -o fork fork.c -std=c99
$ ./fork
+===============+

Чтобы в качестве дочернего процесса вызвать функцию, достаточно вызвать ее после ветвления:
	pid = fork();
	if (pid == 0) {
		// если выполняется дочерний процесс, то вызовем функцию
		process(arg);
		exit(0); // выход из процесса

Таким образом, можно проверить, был ли создан новый процесс: 
	pid = fork();
	if (-1 == pid ){ /* при вызове fork() возникла ошибка*/ }
	else if (0 == pid){ /*это код потомка */} 
	else { /*это код родительского процесса */}

Пример программы демонстрирующий работу системного вызова fork и различное выполнение кода программы для родительского и дочернего процесса:
//--- fork_pid.c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

void doit(){
	pid_t pid;
	int status;
	pid = fork();
	
	if (-1 == pid) {
		perror("fork"); /* произошла ошибка */
		exit(1); /*выход из родительского процесса*/
	} else if (0 == pid){
		printf(" CHILD: Это процесс-потомок!\n");
		printf(" CHILD: Мой PID -- %d\n", getpid());
		printf(" CHILD: PID моего родителя -- %d\n", getppid());
		printf(" CHILD: Введите мой код возврата (как можно меньше):");
		scanf("%d", &status);
		printf(" CHILD: Выход!\n");
		exit(status); /* выход из процесс-потомока */ 
		/*
			ВНИМАНИЕ! НЕ ЗАБЫВАЙТЕ ДЕЛАТЬ return или exit.
		*/
	} else {
		printf("PARENT: Это процесс-родитель!\n");
		printf("PARENT: Мой PID -- %d\n", getpid());
		printf("PARENT: PID моего потомка %d\n",pid);
		printf("PARENT: Я жду, пока потомок не вызовет exit()...\n");
		if (wait(&status) == -1){
			perror("wait() error");
		} else if (WIFEXITED(status)){
			printf("PARENT: Код возврата потомка: %d\n", WEXITSTATUS(status));
		} else {
			perror("PARENT: потомок не завершился успешно");
		}
		printf("PARENT: Выход!\n");
	} //end if
}
	
int main(int argc, char** argv) {
	doit();
}
//---------------

Часто родительскому процессу необходимо обмениваться информацией с дочерними или хотя бы синхронизироваться с ними, чтобы выполнять операции в нужное время.
Один из способов синхронизации процессов — функции wait и waitpid:

	#include <sys/types.h>
	#include <sys/wait.h>

	pid_t wait(int *status);
	pid_t waitpid(pid_t pid, int *status, int options); 

Функция wait приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс не завершится, или до появления сигнала, который либо завершает текущий процесс, либо требует вызвать функцию-обработчик.
Если дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби" ("zombie")), то функция немедленно возвращается.
Системные ресурсы, связанные с дочерним процессом, освобождаются.

Функция waitpid приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, указанный в параметре pid, не завершит выполнение, или пока не появится сигнал, который либо завершает текущий процесс либо требует вызвать функцию-обработчик.
Если указанный дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби"), то функция немедленно возвращается.
Системные ресурсы, связанные с дочерним процессом, освобождаются. 

Параметр pid в функци waitpid может принимать несколько значений:
<-1	означает, что нужно ждать любого дочернего процесса, идентификатор группы процессов которого равен абсолютному значению pid.
-1	означает ожидание любого дочернего процесса; (функция wait ведет себя точно так же) 
0	означает ожидание любого дочернего процесса, идентификатор группы процессов которого равен идентификатору текущего процесса.
>0	означает ожидание дочернего процесса, чей идентификатор равен pid.

Если status не равен NULL, то функции wait и waitpid сохраняют информацию о статусе в переменной, на которую указывает status.
Этот статус можно проверить с помощью нижеследующих макросов (они принимают в качестве аргумента буфер (типа int), а не указатель на буфер!):

WIFEXITED(status)
не равно нулю, если дочерний процесс успешно завершился.

WEXITSTATUS(status)
возвращает восемь младших битов значения, которое вернул завершившийся дочерний процесс.
Эти биты могли быть установлены в аргументе функции exit() или в аргументе оператора return функции main().
Этот макрос можно использовать, только если WIFEXITED вернул ненулевое значение.

WIFSIGNALED(status)
возвращает истинное значение, если дочерний процесс завершился из-за необработанного сигнала.

WTERMSIG(status)
возвращает номер сигнала, который привел к завершению дочернего процесса.
Этот макрос можно использовать, только если WIFSIGNALED вернул ненулевое значение.

WIFSTOPPED(status)
возвращает истинное значение, если дочерний процесс, из-за которого функция вернула управление, в настоящий момент остановлен;
это возможно, только если использовался флаг WUNTRACED или когда подпроцесс отслеживается (см. ptrace(2)).

WSTOPSIG(status)
возвращает номер сигнала, из-за которого дочерний процесс был остановлен.
Этот макрос можно использовать, только если WIFSTOPPED вернул ненулевое значение. 

Так, например, если необходимо узнать состояние порожденного процесса при его завершении и возвращенное им значение, то используют макрос WEXITSTATUS, передавая ему в качестве параметра статус дочернего процесса.
	status=waitpid(pid,&stat,WNOHANG);
	if (pid == status) {
		printf("PID: %d, Result = %d\n", pid, WEXITSTATUS(stat));
	}
В следующем примере программы показано использование fork() и waitpid().
Программа создаёт процесс потомок.
Если программа запущена без параметров, то потомок приостанавливает выполнение с помощью pause(), чтобы позволить пользователю послать сигнал потомку.
Иначе, если в командной строке задан параметр, то потомок завершает работу сразу, используя переданное в параметре командной строки целое число как код завершения.
//--- waitpid.c
#include <sys/wait.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(int argc, char **argv) {
    pid_t pid, w;
    int status;
    pid = fork();
    if (-1 == pid) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    if (0 == pid) { /* Код, выполняемый потомком */
        printf("Child PID is %ld\n", (long) getpid());
        if (1 == argc)
            pause(); /* Ожидание сигналов */
        _exit(atoi(argv[1])); /* выход из процесс-потомока */ 
    } else { /* Код, выполняемый родителем */
        do {
            w = waitpid(pid, &status, WUNTRACED | WCONTINUED);
            if (-1 == w) {
                perror("waitpid");
                exit(EXIT_FAILURE);
            }
            if (WIFEXITED(status)) {
                printf("exited, status=%d\n", WEXITSTATUS(status));
            } else if (WIFSIGNALED(status)) {
                printf("killed by signal %d\n", WTERMSIG(status));
            } else if (WIFSTOPPED(status)) {
                printf("stopped by signal %d\n", WSTOPSIG(status));
            } else if (WIFCONTINUED(status)) {
                printf("continued\n");
            }
        } while (!WIFEXITED(status) && !WIFSIGNALED(status));
        exit(EXIT_SUCCESS);
    }
}
//---------------

+===============+
$ gcc -Wall -o waitpid waitpid.c -std=c99
$ ./waitpid 15
Child PID is 8910
exited, status=15
$ ./waitpid &
Child PID is 8784
$ kill -STOP 8784
stopped by signal 19
$ kill -CONT 8784
continued
$ kill -TERM 8784
killed by signal 15
[1]+  Done
+===============+

Часто в качестве дочернего процесса необходимо запускать другую программу. Для этого применяется функции семейства exec:
	pid = fork(); 
	if (pid == 0) {
		// если выполняется дочерний процесс, то вызов программы
		if (execl("./file","file",arg, NULL)<0) {
			printf("ERROR while start process\n");
			exit(-2);
		} else 
			printf( "process started (pid=%d)\n", pid);
			// выход из процесса 
	}

Для изменения приоритетов порожденных процессов используются функция setpriority.
Приоритеты задаются в диапазоне от -20 (высший) до 20 (низший), нормальное значение - 0.
Заметим, что повысить приоритет выше нормального может только суперпользователь(root)!
	#include <sys/time.h>
	#include <sys/resource.h>
	int process( int i) {
		setpriority(PRIO_PROCESS, getpid(), i);
		printf("Process %d ThreadID: %d working with priority %d\n", i, getpid(), getpriority(PRIO_PROCESS, getpid()));
		return(getpriority(PRIO_PROCESS, getpid()));
	}

Для уничтожения процесса служит функция kill:
	#include <sys/types.h>
	#include <signal.h>
	int kill(pid_t pid, int sig);

Если pid > 0, то он задает PID процесса, которому посылается сигнал. Если pid = 0, то сигнал посылается всем процессам той группы, к которой принадлежит текущий процесс. 
sig - тип сигнала. Некоторые типы сигналов в Linux: 
SIGKILL	Этот сигнал приводит к немедленному завершению процесса. Этот сигнал процесс не может игнорировать.
SIGTERM	Этот сигнал является запросом на завершение процесса.
SIGCHLD	Система посылает этот сигнал процессу при завершении одного из его дочерних процессов. Пример:
	if (pid[i] == status) {
		printf("ThreadID: %d finished with status %d\n", pid[i], WEXITSTATUS(status));
	} else{
		kill(pid[i],SIGKILL);
	}

Пример многозадачной программы, которая считает в дочерних процессах длину строки из аргументов командной строки:
//--- fork_many.c
#include <sys/types.h>
#include <sys/stat.h>
#include <wait.h>
#include <fcntl.h> 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[]) {
    int i, pid[argc], status, stat;
    if (argc < 2) {
        printf("Usage: ./fork_many text text ...\n");
        exit(-1);
    }
    for (i = 1; i < argc; i++) {
        // запускаем дочерний процесс 
        pid[i] = fork();
        srand(getpid());

        if (-1 == pid[i]) {
            perror("fork"); /* произошла ошибка */
            exit(1); /*выход из родительского процесса*/
        } else if (0 == pid[i]) {
            printf(" CHILD: Это %d процесс-потомок СТАРТ!\n", i);
            sleep(rand() % 4);
            printf(" CHILD: Это %d процесс-потомок ВЫХОД!\n", i);
            exit(strlen(argv[i])); /* выход из процесс-потомока */
        }
    }
    // если выполняется родительский процесс
    printf("PARENT: Это процесс-родитель!\n");
    // ожидание окончания выполнения всех запущенных процессов
    for (i = 1; i < argc; i++) {
        status = waitpid(pid[i], &stat, 0);
        if (pid[i] == status) {
            printf("процесс-потомок %d done,  result=%d\n", i, WEXITSTATUS(stat));
        }
    }
    return 0;
}
//---------------

Примеры дочерней (file.c) и родительской (spaces.c) программ многозадачного приложения доступны в каталоге ../src/6 или по адресу http://gun.cs.nstu.ru/ssw/Linuxprog

?===============?
3. МЕТОДИЧЕСКИЕ УКАЗАНИЯ. 
3.1. Для ознакомления с опциями компилятора gcc, описанием функций языка С используйте инструкции man и info.
3.2. Для отладки программ удобно использовать встроенный редактор файлового менеджера Midnight Commander (MC), выделяющий цветом различные языковые конструкции и указывающий в верхней строке экрана положение курсора в файле (строка, столбец).
3.3. В файловом менеджере Midnight Commander имеется буфер команд, вызываемый сочетанием клавиш <ESС> - H, перемещение по которому производится стрелками управления курсором (вверх и вниз). Для вставки команды из буфера в командную строку используется клавиша <Enter>, для редактирования команды из буфера - клавиши <- и ->, <BackSpace> и <Delete>.
3.4. Помните, что текущая директория не содержится в path, поэтому из командной строки необходимо запускать программу как "./print_pid". В MC достаточно навести курсор на файл и нажать <Enter>.
3.5. Для просмотра результата выполнения программы используйте сочетание клавиш <Ctrl> - O. Они работают и в режиме редактирования файла.
3.6. Для компилятора gcc имеется интерактивный  отладчик gdb.
3.7. Для протоколирования результатов выполнения программ целесообразно использовать перенаправление вывода с консоли в файл: ./test > result.txt
3.8. Для доступа к файлам на сервере Linux, применяйте протокол ftp, клиентская программа которого имеется в Windows и встроена в файловые менеджеры FAR и TotalCommander. При этом учетная запись и пароль те же, что и при подключении по протоколу ssh.

4. ПОРЯДОК ВЫПОЛНЕНИЯ РАБОТЫ. 
4.1. Ознакомиться с опциями компилятора gcc, методикой отладки программ. 
4.2. Для вариантов заданий написать и отладить программу, реализующую порожденный процесс.
4.3. Для вариантов заданий написать и отладить программу, реализующую родительский процесс, вызывающий и отслеживающий состояние порожденных процессов - программ (ждущий их завершения или уничтожающий их, в зависимости от варианта).
4.4. Для вариантов заданий написать и отладить программу, реализующую родительский процесс, вызывающий и отслеживающий состояние порожденных процессов - функций (ждущий их завершения или уничтожающий их, в зависимости от варианта).

5. ВАРИАНТЫ ЗАДАНИЙ. 
См. варианты заданий в файле variants.txt.

?===============?

6 КОНТРОЛЬНЫЕ ВОПРОСЫ. 
1. Особенности компиляции и запуска С-программ в Linux.
2. Что такое pid, как его определить в операционной системе и программе?
3. Функция fork - назначение, применение, возвращаемое значение.
4. Как запустить на выполнение в порожденном процессе функцию? Программу?
5. Способы синхронизации родительского и дочерних процессов.
6. Как узнать состояние порожденного процесса при его завершении и возвращенное им значение?
7. Как управлять приоритетами процессов?
8. Как уничтожить процесс в операционной системе и программе?


!===============!
СОСТАВИТЕЛИ:
Гунько А.В., канд. техн. наук, доц. НГТУ
Чистяков Н.А., инженер НГТУ
!===============!

!===============!
ССЫЛКИ:
http://gun.cs.nstu.ru/ssw/Linuxprog.zip
http://gun.cs.nstu.ru/ssw/Linuxprog/
http://gun.cs.nstu.ru/ssw/gdb-html.tgz
http://cpp.com.ru/kr_cbook/index.html
http://cpp.com.ru/shildt_spr_po_c/index.html
http://cpp.com.ru/bogatyrev_c_unix/
https://www.opennet.ru/docs/RUS/linux_parallel/node7.html
https://www.ibm.com/developerworks/ru/library/au-unixprocess/
http://ru.manpages.org/wait/2
!===============!
