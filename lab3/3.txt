СТРУКТУРЫ В ЯЗЫКЕ Си 
ЦЕЛЬ РАБОТЫ:
ознакомиться с понятием структур. Научиться использовать структуру для организации простейших баз данных.

ОСНОВНЫЕ СВЕДЕНИЯ О СТРУКТУРАХ
Структура - это одна или несколько переменных (возможно, различных типов), которые для удобства работы с ними сгруппированы под одним именем.
Структуры помогают в организации сложных данных (особенно в больших программах), поскольку позволяют группу связанных между собой переменных трактовать не как множество отдельных элементов, а как единое целое. 
Объявление структуры создает шаблон, который можно использовать для создания ее объектов (то есть экземпляров этой структуры).
	struct point {
    		int x;
    		int y;
	};
Объявление структуры начинается с ключевого слова struct и содержит список объявлений, заключенный в фигурные скобки.
За словом struct может следовать имя, называемое тегом структуры (от английского слова tag — ярлык, этикетка.), point в нашем случае.
Тег дает название структуре данного вида и далее может служить кратким обозначением той части объявления, которая заключена в фигурные скобки.
Перечисленные в структуре переменные называются элементами. 
Имена элементов и тегов без каких-либо коллизий могут совпадать с именами обычных переменных (т. е. не элементов), так как они всегда различимы по контексту.
Более того, одни и те же имена элементов могут встречаться в разных структурах, хотя, если следовать хорошему стилю программирования, лучше одинаковые имена давать только близким по смыслу объектам. 
Объявление структуры определяет тип. За правой фигурной скобкой, закрывающей список элементов, могут следовать переменные точно так же, как они могут быть указаны после названия любого базового типа.
	struct point {
    		int x;
    		int y;
	} pt1, pt2;
Объявление структуры, не содержащей списка переменных, не резервирует памяти; оно просто описывает шаблон, или образец структуры. 
Однако если структура имеет тег, то этим тегом далее можно пользоваться при определении структурных объектов. 
Например, с помощью заданного выше описания структуры point строка 
	struct point pt;
определяет структурную переменную pt типа struct point. 
Структурную переменную при ее определении можно инициализировать, формируя список инициализаторов ее элементов в виде константных выражений: 
	struct point maxpt = {320, 200};
Доступ к отдельным членам структуры осуществляется с помощью оператора<.> (который обычно называют оператором точка или оператором доступа к члену структуры).
	maxpt.x = 200;
	maxpt.y = 320;

Информация, которая находится в одной структуре, может быть присвоена другой структуре того же типа при помощи единственного оператора присваивания.
Нет необходимости присваивать значения каждого члена в отдельности.
//--- point.c
#include <stdio.h>
struct point{
    int x;
    int y;
} a, b; 

int main(int argc, char **argv){
  a.x = 10;
  b = a;  /* присваение одной структуры другой */
  printf("%d", b.x);
  return 0;
}
//---------------	

Структуры могут быть вложены друг в друга. Одно из возможных представлений прямоугольника - это пара точек на углах одной из его диагоналей:
	struct rect {
	    struct point pt1;
	    struct point pt2;
	};

СТРУКТУРЫ И ФУНКЦИИ
Когда в качестве аргумента функции используется структура, то для передачи целой структуры используется обычный способ вызова по значению. 
Это, конечно, означает, что любые изменения в содержимом параметра внутри функции не отразятся на той структуре, которая передана в качестве аргумента. 
При использовании структуры в качестве аргумента надо помнить, что тип аргумента должен соответствовать типу параметра. 
Если функции передается большая структура, то, чем копировать ее целиком, эффективнее передать указатель на нее.
Указатели на структуры ничем не отличаются от указателей на обычные переменные. Объявление:
	struct point *pp;
сообщает, что pp - это указатель на структуру типа struct point.
адрес структуры person можно присвоить указателю p: 
	pp = &pt1;
Чтобы с помощью указателя на структуру получить доступ к ее членам, необходимо использовать оператор стрелка ->.
Стрелка применяется вместо оператора точки тогда, когда для доступа к члену структуры используется указатель на структуру.
//--- display.c
#include <stdio.h>
struct point{
    int x;
    int y;
}; 
void display(struct point p){
  printf("x=%d\n", p.x);
  printf("y=%d\n", p.y);
}

void move(struct point *p, int dx, int dy){
  p->x+=dx;
  p->y+=dy;
}

int main(int argc, char **argv){
  struct point p = {200, 300};
  move(&p, 20, 30);
  display(p);
  return 0;
}
//---------------	

УПАКОВКА И ВЫРАВНИВАНИЕ СТРУКТУР
Поля структуры расположены в памяти друг за другом.
Тип поля определяет сдвиг относительно предыдущего поля.
Имя поля - это сдвиг относительно адреса экземпляра.
На самом деле размер структуры не всегда равен сумме размеров её полей: это связано с тем, что компилятор оптимизирует расположение структуры в памяти и может поля небольшого размера подгонять до чётных адресов. 
Упаковка структур в Cи — старая, почти забытая, но все еще актуальная тема, если вы занимаетесь низкоуровневыми приложениями.
Первое, что необходимо учесть: на современных процессорах ваш компилятор располагает базовые типы в памяти так, чтобы обеспечить наиболее быстрый доступ к ним.
На процессорах x86 и ARM примитивные типы не могут находиться в произвольной ячейке памяти. 
Каждый тип, кроме char, требует выравнивания. 
char может начинаться с любого адреса, однако двухбайтовый short должен начинаться только с четного адреса, четырехбайтный int или float — с адреса, кратного 4, восьмибайтные long или double — с адреса, кратного 8.
Наличие или отсутствие знака значения не имеет.
Указатели — 32-битные (4 байта) или 64-битные (8 байт) — также выравниваются.
Выравнивание ускоряет доступ к памяти за счет генерации кода, в котором на чтение и запись ячейки памяти требуется по одной инструкции.
В общем случае, экземпляр структуры будет выровнен по самому длинному элементу. Для компилятора это самый простой способ убедиться, что все поля структуры будут также выровнены для быстрого доступа.
Также, в Cи адрес структуры совпадает с адресом ее первого элемента, без сдвига в начале.
Есть возможность изменить упаковку структур в памяти. 
Можно явно указать компилятору каким образом производить упаковку полей структуры, объединений или полей класса. Каким образом это делать, зависит от компилятора.
К примеру, для компилятора gcc можно использовать ключ -fpack-struct при компиляции или атрибут __attribute__((packed)) непосредственно в коде программы.
Пример использования атрибута __attribute__((packed)) компилятора gcc для упаковки структур:
//--- packed.c
#include <stdio.h>
#define N 8
struct simple {
   char a; /* 4 байта */
   int  i; /* 4 байта */
};
 
struct packed {
   char a; /* 1 байт */
   int i; /* 4 байта */
}__attribute__((packed));
 
int main( int argc, char* argv[] ) {
 
  struct simple s1;
  struct packed s2;
 
  printf( "sizeof s1 is %d\n" , sizeof(s1) );
  printf( "sizeof s2 is %d\n" , sizeof(s2) );
 
  struct simple *p1;
  struct packed *p2;
  char mass[N];
  mass[0]='a';
  mass[1]='c';
  for (int i = 2; i < N ; i++){
        mass[i]='b';
   }
  p1 = mass;
  printf("%c\n",p1->a);//под char выделено 4 байта
  printf("%c\n",p1->i);//c 5-го байта
 
  p2 = mass;
  printf("%c\n",p2->a);
  printf("%c\n",p2->i);//c 2-го байта
 
  return( 0 );
}
//---------------	

ОБЪЕДИНЕНИЯ
Объединение — это место в памяти, которое используется для хранения переменных, разных типов. Объединение дает возможность интерпретировать один и тот же набор битов не менее, чем двумя разными способами.
Объявление объединения (начинается с ключевого слова union) похоже на объявление структуры.
Например: 
union u_type {
  int i;
  char ch;
};
Одну и ту же область памяти занимают целая переменная i и символьная переменная ch. Конечно, i занимает 2 байта (при условии, что целые значения занимают по 2 байта), a ch — только 1.
Когда переменная объявляется с ключевым словом union, компилятор автоматически выделяет столько памяти, чтобы в ней поместился самый большой член нового объединения. 
|<------ i ------>|
|                 |
+--------+--------+
| Байт 0 | Байт 1 |
+--------+--------+
|        |
|<- ch ->|

Для получения доступа к члену объединения используйте тот же синтаксис, что и для структур: операторы точки и стрелки.
Объединения часто используются тогда, когда нужно выполнить специфическое преобразование типов, потому что хранящиеся в объединениях данные можно обозначать совершенно разными способами. Например, используя объединения, можно манипулировать байтами, составляющими значение типа double, и делать так, чтобы менять его точность или выполнять какое-либо необычное округление.
Фактически объединение - это структура, все элементы которой имеют нулевое смещение относительно ее базового адреса и размер которой позволяет поместиться в ней самому большому ее элементу, а выравнивание этой структуры удовлетворяет всем типам объединения. 
Операции, применимые к структурам, годятся и для объединений, т. е. законны присваивание объединения и копирование его как единого целого, взятие адреса от объединения и доступ к отдельным его элементам. 
Инициализировать объединение можно только значением, имеющим тип его первого элемента.
//--- union.c
#include <stdio.h>

union u_type {
  int i;
  char ch;
};

struct point{
  int i;
  char ch;
}; 

int main(int argc, char **argv){
  struct point s = {1, 'A'};
  union u_type u = {'A'};
  
  printf("size of union = %i\n", sizeof(u));
  printf("size of structure = %i\n", sizeof(s));

  printf("union.ch = %c\n", u.ch);
  printf("ASCII code union.i = %i\n", u.i);
  u.i++; 
  printf("union.ch = %c\n", u.ch);
  printf("ASCII code union.i = %i\n", u.i);

  printf("struct.ch = %c\n", s.ch);
  printf("ASCII code struct.i = %i\n", s.i);
  s.i++; 
  printf("struct.ch = %c\n", s.ch);
  printf("ASCII code struct.i = %i\n", s.i);

  return 0;
}
//---------------	

+===============+
$ gcc -Wall -std=c99 union.c -o union 
$ ./union
size of union = 4
size of structure = 8
union.ch = A
ASCII code union.i = 65
union.ch = B
ASCII code union.i = 66
struct.ch = A
ASCII code struct.i = 1
struct.ch = A
ASCII code struct.i = 2
+===============+

БИТОВЫЕ ПОЛЯ
В отличие от некоторых других компьютерных языков, в языке С имеется встроенная поддержка битовых полей, которая дает возможность получать доступ к единичному биту.
Битовые поля могут быть полезны по разным причинам, а именно: 
Если память ограничена, то в одном байте можно хранить несколько булевых переменных (принимающих значения ИСТИНА и ЛОЖЬ); 
Некоторые устройства передают информацию о состоянии, закодированную в байте в одном или нескольких битах; 
Для некоторых процедур шифрования требуется доступ к отдельным битам внутри байта. 
Хотя для решения этих задач можно успешно применять побитовые операции, битовые поля могут придать вашему коду больше упорядоченности (и, возможно, с их помощью удастся достичь большей эффективности). 
Битовое поле может быть членом структуры или объединения.
Битовое поле, на самом деле, - это просто особый тип структуры, определяющей, какую длину имеет каждый член.
Общий вид определения битового поля такой: 
	тип имя : длина;
Здесь тип означает тип битового поля, а длина — количество бит, которые занимает это поле. Тип битового поля может быть int, signed или unsigned. (Кроме того, в соответствии со стандартом С99, у битового поля еще может быть тип _Вооl.) 
Битовые поля длиной 1 должны объявляться как unsigned, поскольку 1 бит не может иметь знака. Битовые поля могут иметь длину от 1 до16 бит для 16-битных сред и от 1 до 32 бит для 32-битных сред. 
К каждому полю происходит обращение с помощью оператора "точка". Тем не менее если обращение к структуре происходит с помощью указателя, то следует использовать оператор ->.
Нет необходимости обзывать каждое битовое поле, достаточно указать тип и размер поля. Но к полю, имеющему название, легче получить доступ.
	struct status_type {
	  unsigned :    4; /* битовое поле без имени */
	  unsigned cts: 1;
	  unsigned dsr: 1;
	} status;
Использование битовых полей имеет определенные ограничения.
Нельзя получить адрес битового поля.
Нет массивов битовых данных.
При переносе кода на другую машину неизвестно, будут ли поля обрабатываться справа налево или слева направо; это значит, что выполнение любого кода, в котором используются битовые поля, в определенной степени может зависеть от машины, на которой он выполняется.
Другие ограничения будут зависеть от конкретных реализаций.
Пример компактной упаковки даты с помощью битовых полей: 
/
/--- bitfield.c
#include <stdio.h>
#define YEAR0 2016
struct date
{
  unsigned short day   :5;
  unsigned short month :4;
  unsigned short year  :7;
};
int main( int argc, char* argv[] ) {
  struct date today;
  today.day = 2;
  today.month = 2;
  today.year = 2017 - YEAR0;
  
  printf("Сегодня %u.%u.%u \n", today.day, today.month, today.year+YEAR0);
  printf("Размер структуры today: %d байт\n", sizeof(today));
  printf("Значение элемента today = %hu = %hx шестн.", today, today);
 
  return 0;
}
//---------------	

СРЕДСТВО TYPEDEF
Язык Си предоставляет средство, называемое typedef, которое позволяет давать типам данных новые имена.
На самом деле таким способом новый тип данных не создается, а всего лишь определяется новое имя для уже существующего типа.
Фактически typedef аналогичен #define с тем лишь отличием, что при интерпретации компилятором он может справиться с такой текстовой подстановкой, которая не может быть обработана препроцессором.
Помимо просто эстетических соображений, для применения typedef существуют две важные причины. 
Первая - параметризация программы, связанная с проблемой переносимости. 
Этот процесс может помочь сделать машинно-зависимые программы более переносимыми. 
Если вы для каждого машинно-зависимого типа данных, используемого в вашей программе, определяете данное вами имя, то при компиляции для новой среды придется менять только операторы typedef. 
Вторая причина, побуждающая к применению typedef,- желание сделать более ясным текст программы. 
Общий вид декларации typedef (оператора typedef) такой: 
	typedef тип новое_имя;
где тип — это любой тип данных языка С, а новое_имя — новое имя этого типа. Новое имя является дополнением к уже существующему, а не его заменой. 
Пример использования typedef и динамического выделения памяти для указателей на структуры, сортировка с помощью функции qsort:
//--- sort.c
#include <stdio.h>
#include <stdlib.h>
struct student{
    char name[50];
    int balls;
};
typedef struct student students;
 
void readStudent(students *st){
    printf("Введите Имя:");
    scanf("%s", st->name);
    printf("Введите баллы:");
    scanf("%d", &st->balls);
}

static int cmp(const void *p1, const void *p2){
    students * st1 = *(students**)p1;
    students * st2 = *(students**)p2;
    return st2->balls - st1->balls;
}
 
int main(int argc, char **argv){
    int count = 3;
    printf("Введите кол-во студентов:");
    scanf("%d", &count);
    students** st = (students**)malloc(sizeof(students**)*count);
    for (int i = 0; i < count ; i++){
        st[i] = (students*) malloc (sizeof(students));
        readStudent(st[i]);
    } 
    qsort(st, count, sizeof(students*), cmp);
    printf("Имя студента:%s\n", st[0]->name);
    printf("Балл:%d\n", st[0]->balls);
    for (int i = 0; i < count; i++)
    {
        free(st[i]);
    }
    free(st);
    return 0;
}
//---------------	


?===============?
ЗАДАНИЕ:
1. 
Написать программу, работающую с базой данных в виде массива структур и выполняющую последовательный ввод данных в массив и последующую распечатку его содержимого. 
Состав структуры приведен в варианте.
Типы данных выбрать самостоятельно.
При написании программы следует использовать статические массивы структур или указателей на структуру.
Размерности массивов – 3–4. 
Ввод данных выполнить с помощью функций scanf().

2. 
Модифицировать программу, используя массив указателей на структуру и динамическое выделение памяти. 
Выполнить сортировку массива с помощью функции qsort. 
Способ сортировки массива приведен в варианте.
Для динамического выделения памяти используйте функцию malloc().
Для определения размера структуры в байтах удобно использовать операцию sizeof(), возвращающую целую константу: 
	struct ELEM *sp; 
	sp = malloc(sizeof(struct ELEM));

Варианты:
1
Фамилия 
Год рождения 
Номер отдела 
Оклад 
Расположить записи в массиве в порядке возрастания (по году рождения) 

2
Название детали 
Год выпуска 
Стоимость 
Количество 
Расположить записи в массиве в порядке возрастания стоимости 

3
Название книги 
Год издания 
Количество страниц Стоимость 
Расположить записи в массиве в алфавитном порядке (по названию) 

4
Фамилия 
Дата рождения 
Телефон 
Сумма долга 
Все записи с суммой долга, не равной 0, разместить в начале массива 

5
Название покупки 
Дата приобретения Стоимость 
Количество 
Сгруппировать все записи по месяцам приобретения 

6
Название команды 
Игры 
Очки 
Сумма призового фонда 
Расположить записи в порядке возрастания по сумме призового фонда 

7
Фамилия 
Группа 
Номер в списке 
Стипендия 
Расположить записи в порядке возрастания номера в списке 

8
Название маршрута
Протяженность
Количество остановок
Стоимость путевки 
Расположить записи в порядке убывания стоимости 

9
Фамилия спортсмена 
Вид спорта 
Количество медалей
Расположить в алфавитном порядке записи с ненулевым количеством медалей 


10
Фамилия 
Группа 
Место прохождения практики 
Оценка 
Расположить записи в массиве в порядке убывания оценки 
?===============?

!===============!
СОСТАВИТЕЛИ:
Гунько А.В., канд. техн. наук, доц. НГТУ
Чистяков Н.А., инженер НГТУ
!===============!

!===============!
ССЫЛКИ:
http://cpp.com.ru/kr_cbook/index.html
http://cpp.com.ru/shildt_spr_po_c/index.html
http://cpp.com.ru/bogatyrev_c_unix/
https://tproger.ru/translations/art-of-structure-packing/
http://www.linuxquestions.org/questions/programming-9/what's-this-__attribute__-packed-193570/
https://gcc.gnu.org/onlinedocs/gcc-3.2.1/gcc/Type-Attributes.html
http://learnc.info/c/structures.html
http://learnc.info/c/unions_and_bitfields.html
http://www.c-cpp.ru/books/bitovye-polya
https://www.opennet.ru/base/dev/valgrind_memory.txt.html
!===============!
