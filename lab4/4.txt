ИНТЕРФЕЙС С ОПЕРАЦИОННОЙ СИСТЕМОЙ.ФАЙЛОВЫЕ ОПЕРАЦИИ.
ЦЕЛЬ РАБОТЫ:
ознакомиться со стандартными функциями языка СИ, используемыми для организации доступа к файлам. Научиться использовать аргументы командной строки.

ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ

АРГУМЕНТЫ КОМАНДНОЙ СТРОКИ
В операционной среде, обеспечивающей поддержку Си, имеется возможность передать аргументы или параметры запускаемой программе с помощью командной строки.
В момент вызова main получает два аргумента.
В первом, обычно называемом argc (сокращение от argument count), стоит количество аргументов, задаваемых в командной строке.
Второй, argv (от argument vector), является указателем на массив символьных строк, содержащих сами аргументы. 
По соглашению argv[0] есть имя вызываемой программы, так что значение argc никогда не бывает меньше 1. Если argc равен 1, то в командной строке после имени программы никаких аргументов нет.
Все аргументы командной строки являются строковыми, поэтому преобразование каких бы то ни было чисел в нужный двоичный формат должно быть предусмотрено в программе при ее разработке.
//--- argv.c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
	char *end;
	if (argc < 2){
        printf("Неверное кол-во параметров\n");
        exit(1);
    }    
  	printf("argv[0]=%s\n", argv[0]);
	printf("argv[1]=%ld\n", strtol(argv[1], &end, 10));
	printf("argv[1]=%d\n", atoi(argv[1]));
	return 0;
}
//---------------
+===============+
$ gcc -Wall -o argv argv.c -std=c99
$ ./argv 10abc
argv[0]=./argv
argv[1]=10
argv[1]=10
+===============+

Практически в каждой программе на Си требуется разбирать параметрые переданные через argc/argv из коммандной строки при запуске программы, проще всего для этого использовать функцию getopt и getopt_long из библиотеки unistd.h и  с версии C99 getopt.h.
Пример программы, которая используюет аргументы командной строки и подсчитывает значение линейного уравнения a*x + b:
//--- getopt.c
#include <stdlib.h>
#include <stdio.h>
#include <getopt.h>

int main(int argc, char *argv[]){
  int opt = 0;
  printf("%s ",argv[0]);
  int a, b, x, y = 0;
  while( (opt = getopt(argc, argv, ":a:b:x:")) != -1){
	switch (opt) {
		
    case 'a':
		a = atoi(optarg);
    break;

    break;

    case 'b':
		b = atoi(optarg);
    break;

    case 'x':
		x = atoi(optarg);
    break;
    
    default: /* '?' */
		fprintf(stderr, "Использование ax+b: %s [-a paramA] [-b paramB] [-x varible]\n", argv[0]);
		exit(EXIT_FAILURE);
	}
	  
    printf("-%c %s ", opt, optarg);
  };
  y = a*x + b;
  printf("\n");
  printf("a*x+b=%d", y);
  printf("\n");
  return 0;
}
//---------------

+===============+
$ gcc -Wall -o getopt getopt.c -std=c99
$ ./getopt -a 10 -b 5 -x 1
./getopt -a 10 -b 5 -x 1 
a*x+b=15
+===============+

МОДЕЛЬ КИС
Любая программа имеет свой репозиторий - рабочий каталог, в котором находятся исходники, сценарии сборки (Makefile) и прочие файлы, относящиеся к проекту. 
Практика показывает, что правильная организация исходного кода в репозитории не только упрощает модернизацию и отладку, но и предотвращает возможность появления многих ошибок. 
Модель КИС (Клиент-Интерфейс-Сервер) - это элегантная концепция распределения исходного кода в репозитории, в рамках которой все исходники можно поделить на клиенты, интерфейсы и серверы. 
Итак, сервер предоставляет услуги. В нашем случае это могут быть функции, структуры, перечисления, константы, глобальные переменные и проч. 
В языке C++ это чаще всего классы или иерархии классов. 
Любой желающий (клиент) может воспользоваться предоставленными услугами, то есть вызвать функцию со своими фактическими параметрами, создать экземпляр структуры, воспользоваться константой и т. п. 
В C++, как правило, клиент использует класс как тип данных и использует его члены. 
Часто бывает, что клиент сам становится сервером, точнее начинает играть роль промежуточного сервера. 
Клиент с сервером должны "понимать" друг друга, иначе взаимодействие невозможно. Интерфейс (протокол) - это условный набор правил, согласно которым взаимодействуют клиент и сервер. 
Обычно для организации интерфейсов используются объявления (прототипы), которые помещаются чаще всего в заголовочные файлы. В языке Cи это файлы с расширением .h.

ПОТОКИ
Все потоки ведут себя похожим образом. И так как они в основном не зависят от физических устройств, то та же функция, которая выполняет запись в дисковый файл, может ту же операцию выполнять и на другом устройстве, например, на консоли. Потоки бывают двух видов: текстовые и двоичные.

Текстовый поток — это последовательность символов. В стандарте Си считается, что текстовый поток организован в виде строк, каждая из которых заканчивается символом новой строки. Однако в конце последней строки этот символ не является обязательным.В текстовом потоке по требованию базовой среды могут происходить определенные преобразования символов.

Двоичный поток — это последовательность байтов, которая взаимно однозначно соответствует байтам на внешнем устройстве, причем никакого преобразования символов не происходит. Кроме того, количество тех байтов, которые пишутся (читаются), и тех, которые хранятся на внешнем устройстве, одинаково. Однако в конце двоичного потока может добавляться определяемое приложением количество нулевых байтов. Такие нулевые байты, например, могут использоваться для заполнения свободного места в блоке памяти незначащей информацией, чтобы она в точности заполнила сектор на диске. 

В языке Си файлом может быть все что угодно, начиная с дискового файла и заканчивая терминалом или принтером. 
Поток связывают с определенным файлом, выполняя операцию открытия. Как только файл открыт, можно проводить обмен информацией между ним и программой. 

Файл отсоединяется от определенного потока (т.е. разрывается связь между файлом и потоком) с помощью операции закрытия.
При закрытии файла, открытого с целью вывода, содержимое (если оно есть) связанного с ним потока записывается на внешнее устройство. Этот процесс, который обычно называют дозаписью потока, гарантирует, что никакая информация случайно не останется в буфере диска. 
Если программа завершает работу нормально, т.е. либо main() возвращает управление операционной системе, либо вызывается exit(), то все файлы закрываются автоматически.
В случае аварийного завершения работы программы, например, в случае краха или завершения путем вызова abort(), файлы не закрываются.

СИСТЕМНЫЕ ВЫЗОВЫ
В языке C для осуществления файлового ввода-вывода используются механизмы стандартной библиотеки языка, объявленные в заголовочном файле stdio.h.

С точки зрения модели КИС (Клиент-Интерфейс-Сервер), сервером стандартных механизмов ввода вывода языка C (printf, scanf, FILE*, fprintf, fputc и т. д.) является библиотека языка. А сервером низкоуровневого ввода-вывода в Linux является само ядро операционной системы. 

Пользовательские программы взаимодействуют с ядром операционной системы посредством специальных механизмов, называемых системными вызовами (system calls, syscalls).
Внешне системные вызовы реализованы в виде обычных функций языка C, однако каждый раз вызывая такую функцию, мы обращаемся непосредственно к ядру операционной системы.
Список всех системных вызовов Linux можно найти в файле /usr/include/asm/unistd.h.
Основные системные вызовы, осуществляющие ввод-вывод: open(), close(), read(), write(), lseek().

БИБЛИОТЕЧНЫЕ ФУНКЦИИ
Проблема использования низкоуровневых системных вызовов непосредственно для ввода и вывода заключается в том, что они могут быть очень неэффективны. Почему? Ответ может быть следующим.
При выполнении системных вызовов существуют эксплуатационные издержки. 
Поэтому системные вызовы требуют больше затрат по сравнению с библиотечными функциями, т.к. ОС Linux вынуждена переключаться с выполнения вашего программного кода на собственный код ядра и затем возвращаться к выполнению вашей программы. 
Было бы неплохо стараться свести к минимуму применение системных вызовов в программе и заставлять каждый такой вызов выполнять максимально возможный объем работы, например, считывать и записывать за один раз большие объемы данных, а не одиночные символы.
У оборудования есть ограничения, накладываемые на размер блока данных, которые могут быть считаны или записаны в любой конкретный момент времени. 
Для формирования высокоуровневого интерфейса для устройств и дисковых файлов дистрибутив Linux (и UNIX) предоставляет ряд стандартных библиотек. 
Они представляют собой коллекции функций, которые вы можете включать в свои программы для решения подобных проблем. 
Хорошим примером может послужить стандартная библиотека ввода/вывода, обеспечивающая буферизованный вывод. 
Вы сможете эффективно записывать блоки данных разных размеров, применяя библиотечные функции, которые будут выполнять низкоуровневые системные вызовы, снабжая их полными блоками, как только данные станут доступны. 
Это существенно снижает издержки системных вызовов.

При запуске Си-программы операционная система всегда открывает три файла и обеспечивает три файловые ссылки на них. 
Этими файлами являются: стандартный ввод, стандартный вывод и стандартный файл ошибок; соответствующие им указатели называются stdin, stdout и stderr; они описаны в <stdio.h>.
Обычно stdin соотнесен с клавиатурой, а stdout и stderr - с экраном. 
Однако stdin и stdout можно связать с файлами или, используя конвейерный механизм, соединить напрямую с другими программами
Файловые указатели stdin и stdout представляют собой объекты типа FILE*. Это константы, а не переменные, следовательно, им нельзя ничего присваивать. 
Указатель файла — это указатель на структуру типа FILE. Он указывает на структуру, содержащую различные сведения о файле, например, его имя, статус и указатель текущей позиции в начало файла.
В сущности, указатель файла определяет конкретный файл и используется соответствующим потоком при выполнении функций ввода/вывода.

Для того чтобы можно было читать из файла или писать в файл, он должен быть предварительно открыт с помощью библиотечной функции fopen.
	FILE *fp;
	FILE *fopen(char *name, char *mode);
Первый аргумент - строка, содержащая имя файла. Второй аргумент несет информацию о режиме. Это тоже строка: в ней указывается, каким образом пользователь намерен применять файл. 

Функция fopen() открывает поток и связывает с этим потоком определенный файл. Затем она возвращает указатель этого файла. 
Возможны следующие режимы: чтение (read - "r"), запись (write - "w") и добавление (append - "a"), т. е. запись информации в конец уже существующего файла. 
В некоторых системах различаются текстовые и бинарные файлы; в случае последних в строку режима необходимо добавить букву "b" (binary - бинарный). 
Тот факт, что некий файл, которого раньше не было, открывается на запись или добавление, означает, что он создается (если такая процедура физически возможна). 
Открытие уже существующего файла на запись приводит к стиранию его старого содержимого, в то время как при открытии файла на добавление его старое содержимое сохраняется. 
Попытка читать несуществующий файл является ошибкой. 
Функция fclose() закрывает поток, который был открыт с помощью вызова fopen().
Функция fclose() записывает в файл все данные, которые еще оставались в дисковом буфере, и проводит, так сказать, официальное закрытие файла на уровне операционной системы.
Отказ при закрытии потока влечет всевозможные неприятности, включая потерю данных, испорченные файлы и возможные периодические ошибки в программе.
Функция fclose() также освобождает блок управления файлом, связанный с этим потоком, давая возможность использовать этот блок снова.
	int fclose(FILE *fp);
Так как в большинстве операционных систем количество одновременно открытых одной программой файлов ограничено, то файловые указатели, если они больше не нужны, лучше освобождать.

Функция fputc() записывает символ ch в текущую позицию потока stream, a затем увеличивает указатель текущей позиции файла.
	int fputc(int ch, FILE *stream);
 Хотя на практике при объявлении символа ch он всегда имеет тип int, функцией fputc() тип символа преобразуется в unsigned char.
Поскольку в момент вызова символьный аргумент преобразуется к целому типу, в качестве аргументов обычно можно использовать и символьные переменные.
При использовании целого значения, старший байт попросту отбрасывается. 
Значением, возвращаемым функцией fputc(), является значение записанного символа.
При возникновении ошибки возвращается значение EOF.
Если файл открыт для выполнения операций в двоичном режиме, значение EOF тоже может оказаться символом. Поэтому, чтобы определить, возникла ли ошибка на самом деле, в таких случаях придется использовать функцию ferror(). 
//--- fputc.c
#include <stdio.h>
#include <stdlib.h>

void write_string(char *str, FILE *fp){
  while(*str){ 
	if(!ferror(fp)){
		fputc(*str++, fp);
	}	
  }	
}

int main(int argc, char *argv[]){
	FILE *fp;
	if (argc < 3){
		fprintf (stderr, "Мало аргументов. Используйте <имя файла> <строка>\n");
		exit (1);
	}
	if((fp=fopen(argv[1], "a"))==NULL) {
		printf("Не удается открыть файл.\n");
		exit(1);
	}
	write_string(argv[2], fp);
	if(fclose(fp)){ 
		printf("Ошибка при закрытии файла.\n");
		exit(1);
	}
   return 0;
}
//---------------


+===============+
$ gcc -Wall -o fgetc fgetc.c -std=c99
$ ./fgets test.txt Hello
$ cat test.txt 
Hello
+===============+

Функция fgetc() возвращает символ, взятый из входного потока stream и находящийся сразу после текущей позиции, а также увеличивает указатель текущей позиции файла. 
Этот символ читается как значение типа unsigned char, преобразованное в целое. 
	int fgetc(FILE *stream);
При достижении конца файла функция fgetc() возвращает значение EOF. Ho по скольку значение EOF является действительным целым значением, при работе с двоичными файлами для обнаружения конца файла необходимо использовать функцию feof(). 
Если функция fgetc() обнаруживает ошибку, она возвращает значение EOF.
Для выявления ошибок, возникающих при работе с двоичными файлами, необходимо использовать функцию ferror(). 
//--- fgetc.c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
  FILE *fp;
  char ch;

  if((fp=fopen(argv[1],"r"))==NULL) {
    printf("Невозможно открыть файл.\n");
    exit(1);
  }

  while((ch=fgetc(fp)) != EOF) {
    printf("%c", ch);
  }
  
  fclose(fp);
  return 0;
}
//---------------

Функция fwrite() записывает в поток, адресуемый указателем stream, count объектов длиной size байтов каждый из массива символов, адресуемого указателем buf. Затем указатель текущей позиции файла перемещается вперед на записанное количество символов. 
В версии C99 к параметрам buf и stream применен квалификатор restrict. 
	size_t fwrite(const void *buf, size_t size, size_t count, FILE *stream);
Функция fwrite() возвращает число реально записанных элементов, которое при успешном выполнении функции будет равно числу затребованных элементов. 
Если же элементов записано меньше, чем указано при вызове, произошла ошибка. 
//--- fwrite.c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char ** argv){
  FILE *fp;
  float f = 77.7;
   
  if (argc < 2){
		fprintf (stderr, "Мало аргументов. Используйте <имя файла>\n");
		exit (1);
  }
  
  if((fp=fopen(argv[1], "wb"))==NULL) {
    printf("Не удается открыть файл.\n");
    exit(1);
  }
  fwrite(&f, sizeof(float), 1, fp);

  if(fclose(fp)){ 
	printf("Ошибка при закрытии файла.\n");
	exit(1);
  }

  printf("f=%f\n", f);
  return 0;
}
//---------------

Функция fread() читает из потока, адресуемого указателем stream, count объектов длиной size байт и размещает их в массиве buf. Затем указатель текущей позиции файла увеличивается на число, равное прочитанному количеству символов. 
В версии C99 к параметрам buf и stream применен квалификатор restrict. 
	size_t fread(void *buf, size_t size, size_t count, FILE *stream);
Функция fread() возвращает число реально прочитанных элементов. 
Если оказалось, что прочитано меньше элементов, чем требовалось при вызове, значит, либо произошла ошибка при выполнении операции, либо был достигнут конец файла. 
Определить, что именно произошло, можно с помощью функции feof() или ferror().

//--- fread.c
int main(int argc, char ** argv){
  FILE *fp;
  float f = 0;
   
  if (argc < 2){
		fprintf (stderr, "Мало аргументов. Используйте <имя файла>\n");
		exit (1);
  }

  if((fp=fopen(argv[1], "r"))==NULL) {
    printf("Не удается открыть файл.\n");
    exit(1);
  }
  fread(&f, sizeof(float), 1, fp);

  if(fclose(fp)){ 
	printf("Ошибка при закрытии файла.\n");
	exit(1);
  }

  printf("f=%f\n", f);
  return 0;
}
//---------------
?===============?
ЗАДАНИЕ:
В лабораторной работе требуется написать две программы для обработки текстовых файлов. Одна из них выполняет построчную, другая посимвольную обработку:
	1. Написать программу, обрабатывающую текстовый файл и 	записывающую обработанные данные в файл с таким же именем, но 	с другим типом (табл. 3).

	2.Написать программу, выполняющую посимвольную обработку 	текстового файла (табл. 4). 

Ввод параметров должен быть организован в командной строке запуска программы. 
Исходный файл должен быть создан с помощью любого текстового редактора. 
При обработке текста рекомендуется использовать функции из стандартной библиотеки СИ для работы со строками, преобразования и анализа символов.

Таблица 3.
Варианты
1
Исключить строки с длиной, больше заданной
Параметры командной строки: 
	1. Имя входного файла 
	2. Заданная длина строки

2
Оставить только строки, начинающиеся с латинских букв 
Параметры командной строки:
	1. Имя входного файла
	2. Количество обрабатываемых строк 

3
Исключить строки, начинающиеся с заданного слова 
Параметры командной строки:
	1. Имя входного файла 
	2. Заданное слово

4
Оставить строки, начинающиеся с заданной буквы 
Параметры командной строки:
	1. Имя входного файла 
	2. Заданная буква 
5
Исключить строки с количеством пробелов, большим заданного числа 
Параметры командной строки:
	1. Имя входного файла 
	2. Заданное количество пробелов 
6
Оставить строки, не содержащие цифры 
Параметры командной строки:
	1. Имя входного файла 
	2. Количество обрабатываемых строк 
7
Оставить строки, заканчивающиеся цифрами 
Параметры командной строки:
	1. Имя входного файла 
	2. Максимальная длина строки 
8
Исключить строки, содержащие хотя бы один заданный символ 
Параметры командной строки:
	1. Имя входного файла 
	2. Заданный символ
9
Оставить строки, содержащие заданное количество цифр
Параметры командной строки:
	1. Имя входного файла 
	2. Заданное количество цифр 
10
Исключить строки, содержащие заданное слово 
Параметры командной строки:
	1. Имя входного файла 
	2. Заданное слово 


Таблица 4.
Варианты
1
Удалить из текста заданный символ 
Параметры командной строки:
	1. Имя входного файла 
	2. Заданный символ
2
В конце каждой строки вставить заданный символ 
Параметры командной строки:
	1. Имя входного файла 
	2. Заданный символ
3
Заменить цифры на пробелы 
Параметры командной строки:
	1. Имя входного файла 
	2. Количество замен 
4
Заменить знаки на заданный символ 
Параметры командной строки:
	1. Имя входного файла 
	2. Заданный символ
5
Заменить каждый пробел на два 
Параметры командной строки:
	1. Имя входного файла 
	2. Количество замен 
6
После каждой точки вставить символ ‘\n’
Параметры командной строки:
	1. Имя входного файла 
	2. Количество вставок 
7
Удалить из текста все пробелы 
Параметры командной строки:
	1. Имя входного файла 
	2. Количество замен 
8
Заменить заданные символы на пробелы 
Параметры командной строки:
	1. Имя входного файла 
	2. Заданный символ
9
После каждого пробела вставить точку 
Параметры командной строки:
	1. Имя входного файла 
	2. Количество вставок 
10
Заменить все пробелы первым символом текста 
Параметры командной строки:
	1. Имя входного файла 
	2. Количество замен 
?===============?

!===============!
СОСТАВИТЕЛИ:
Гунько А.В., канд. техн. наук, доц. НГТУ
Чистяков Н.А., инженер НГТУ
!===============!

!===============!
ССЫЛКИ:
http://cpp.com.ru/kr_cbook/index.html
http://cpp.com.ru/shildt_spr_po_c/index.html
http://cpp.com.ru/bogatyrev_c_unix/
https://www.opennet.ru/docs/RUS/zlp/005.html
http://www.redov.ru/kompyutery_i_internet/osnovy_programmirovanija_v_linux/p7.php
http://www.ibm.com/developerworks/ru/library/au-unix-getopt/
http://gun.cs.nstu.ru/cpp
!===============!
